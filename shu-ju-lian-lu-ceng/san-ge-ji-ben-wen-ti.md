# 封装成帧（帧定界）
为了使传输中发生差错后只将出错的有限数据进行重发，而不是将全部数据重传，数据链路层**将比特流组织成以帧为单位传送**
帧的结构必须设计成使接收方能够明确地从物理层收到的比特流中对其进行识别，即**能从比特流中区分出帧的起始与终止**
![](/.src/pic/封装成帧.png)
其中 MTU 为最大传输单元

# 透明传输
当所传数据中的比特组合恰巧**出现了与某一个控制信息完全一样**时，必须有可靠的措施，使接收方不会将这种比特组合的数据误认为是某种控制信息
![](/.src/pic/透明传输.png)
采用**字节填充**，即数据中出现字符“SOH”或“EOT”时，就在它的前面插入一个转义字符。接收端的数据链路层在将数据送往网络层之前**删除插入的转义字符**
如果转义字符也出现数据当中，那么应在转义字符前面**再插入一个转义字符**。当接收端收到连续的两个转义字符时，就删除其中前面的一个
![](/.src/pic/透明传输1.png)

# 差错检测
传输过程中会出现差错，为了保证数据传输的可靠性，必须采用差错检测措施，让接收方可以检测出有差错的帧并丢弃它，只接收正确的帧
广泛使用 [CRC](https://www.wikiwand.com/zh-hans/%E5%BE%AA%E7%92%B0%E5%86%97%E9%A4%98%E6%A0%A1%E9%A9%97) 检测技术+ [FCS](https://www.wikiwand.com/en/Frame_check_sequence) 数据冗余码 ~CRC和FCS不同~
![](/.src/pic/CRC.png)
除了CRC以外还有 奇偶校验、效验和

奇偶校验：偶效验是判断一个字符中含有1（包括效验位本身）的个数是偶数，则效验位为1。如0100101的效验位是1。奇效验是判断一个字符中含有1（包括效验位本身）的个数是奇数，则效验位为1。如0101101的效验位是1。 检验方式简单但检错能力不高

效验和：把要发送的数据看成二进制整数序列，并计算他们的和。大多数网络应用16位或32位效验和技术。把每对字符当成16位整数处理并计算效验和。如果效验和大于16位，那么把进位一起加到最后的效验和中。
![](/.src/pic/checksum.png)